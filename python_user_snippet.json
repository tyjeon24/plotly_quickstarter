{
	"plotly_1_basic_user_code_snippet":{
		"prefix":"plotly_1_basic_user_code_snippet",
		"body":[
				"from plotly.subplots import make_subplots",
				"import plotly.graph_objects as go",
				"",
				"fig = make_subplots(rows=3, cols=1,shared_xaxes=True,vertical_spacing=0.02)",
				"fig.add_trace(go.Scatter(x=[0, 1, 2], y=[10, 11, 12], name='PLOT 1'),row=3, col=1)",
				"fig.add_trace(go.Scatter(x=[2, 3, 4], y=[100, 110, 120], name='PLOT 2'),row=2, col=1)",
				"fig.add_trace(go.Scatter(x=[3, 4, 5], y=[1000, 1100, 1200], name='PLOT 3'),row=1, col=1)",
				"fig.update_layout(height=600, width=600,title_text='Stacked Subplots with Shared X-Axes', title_x=0.5)",
				"fig.show()",
				"import plotly.graph_objects as go",
				"from plotly.subplots import make_subplots",
				"",
				"fig = make_subplots(specs=[[{'secondary_y': True}]])",
				"fig.add_trace(go.Scatter(x=[1, 2, 3], y=[40, 50, 60], name='왼쪽'),secondary_y=False)",
				"fig.add_trace(go.Scatter(x=[2, 3, 4], y=[4, 5, 6], name='오른쪽'),secondary_y=True)",
				"fig.update_layout(title_text='제목', title_x=0.5)",
				"fig.update_xaxes(title_text='X축 제목')",
				"fig.update_yaxes(title_text='&lt;b&gt;왼쪽 제목&lt;/b&gt;', secondary_y=False)",
				"fig.update_yaxes(title_text='오른쪽 제목', secondary_y=True)",
				"fig.show()"
		]
	},
	"콜백+부트스트랩":{
		"prefix":"dash_1_basic_user_code_snippet",
		"body":[
				"import dash",
				"import dash_bootstrap_components as dbc",
				"from dash import Input, Output, html",
				"",
				"white_button_style = {'background-color': 'white', 'color': 'black'}",
				"red_button_style = {'background-color': 'red', 'color': 'white'}",
				"",
				"app = dash.Dash(external_stylesheets=[dbc.themes.DARKLY])",
				"click_counter_button = dbc.Button('Click me', className='me-2', n_clicks=0)",
				"app.layout = html.Div([click_counter_button, number_of_click_text := html.Span()])",
				"",
				"",
				"@app.callback(",
				"    [Output(number_of_click_text, 'children'),",
				"     Output(click_counter_button, 'children'),",
				"     Output(click_counter_button, 'style')],",
				"    [Input(click_counter_button, 'n_clicks')],",
				")",
				"def on_button_click(n):",
				"    style = red_button_style",
				"    if n % 2 == 0:",
				"        style = white_button_style",
				"    return f'Clicked {n} times.', n, style",
				"",
				"",
				"if __name__ == '__main__':",
				"    app.run_server()"
		]
	},
	"애니메이션":{
		"prefix":"dash_2_animation_user_code_snippet",
		"body":[
				"from dash import Dash, dcc, html, Input, Output, clientside_callback, State",
				"import pandas as pd",
				"import numpy as np",
				"",
				"df = pd.DataFrame({",
				"    'x' : [i for i in range(10000)],",
				"    'phase_1' : [np.sin(4*np.pi*i*0.01) for i in range(10000)],",
				"    'phase_2' : [np.sin(4*np.pi*i*0.01 - 2*(np.pi)/3) for i in range(10000)],",
				"    'phase_3' : [np.sin(4*np.pi*i*0.01 - (np.pi)/3) for i in range(10000)],",
				"})",
				"",
				"app = Dash(__name__)",
				"app.layout = html.Div([",
				"    dcc.Graph(id='clientside-graph'),",
				"    dcc.Interval(id='interval', interval=25),",
				"    dcc.Store(id='sin_wave',data=df.to_dict('list'))",
				"])",
				"",
				"clientside_callback(",
				"    '''",
				"    function(n_intervals, data) {",
				"            return [{",
				"            'data':[",
				"                        {",
				"                            'x':data['x'].slice(0,n_intervals),",
				"                            'y':data['phase_1'].slice(0,n_intervals)",
				"                        },",
				"                        {",
				"                            'x':data['x'].slice(0,n_intervals),",
				"                            'y':data['phase_2'].slice(0,n_intervals)",
				"                        },",
				"                        {",
				"                            'x':data['x'].slice(0,n_intervals),",
				"                            'y':data['phase_3'].slice(0,n_intervals)",
				"                        }",
				"                    ]",
				"                },",
				"            ];",
				"        }",
				"    ''',",
				"    [Output('clientside-graph', 'figure')],",
				"    [Input('interval', 'n_intervals')],",
				"    [State('sin_wave', 'data')],",
				")",
				"",
				"if __name__ == '__main__':",
				"    app.run(debug=True)"
		]
	},
	"비동기 요청":{
		"prefix":"async_1_requests_user_code_snippet",
		"body":[
			"# https://www.twilio.com/blog/asynchronous-http-requests-in-python-with-aiohttp",
			"import aiohttp",
			"import asyncio",
			"import sys",
			"import time",
			"",
			"if USING_NOTEBOOK:='ipykernel' in sys.modules:",
			"    import nest_asyncio",
			"    nest_asyncio.apply()",
			"",
			"start = time.time()",
			"",
			"async def get_info(session, url):",
			"    async with session.get(url) as resp:",
			"        response = await resp.json()",
			"        data = response['name']",
			"        return data",
			"",
			"async def main():",
			"    async with aiohttp.ClientSession() as session:",
			"        tasks = [asyncio.ensure_future(get_info(session, f'https://pokeapi.co/api/v2/pokemon/{number}')) for number in range(1, 151)]",
			"        result = await asyncio.gather(*tasks)",
			"    return result",
			"",
			"result = asyncio.run(main())",
			"print(result)",
			"print(time.time() - start)"
		]
	},
	
	"opencv_1_color_selector_user_code_snippet":{
		"prefix":"opencv_1_color_selector_user_code_snippet",
		"body":[
				"# https://stackoverflow.com/a/57469788",
				"import cv2",
				"import sys",
				"import numpy as np",
				"",
				"def nothing(x):",
				"    pass",
				"",
				"# Create a window",
				"cv2.namedWindow('image')",
				"",
				"# create trackbars for color change",
				"cv2.createTrackbar('HMin','image',0,179,nothing) # Hue is from 0-179 for Opencv",
				"cv2.createTrackbar('SMin','image',0,255,nothing)",
				"cv2.createTrackbar('VMin','image',0,255,nothing)",
				"cv2.createTrackbar('HMax','image',0,179,nothing)",
				"cv2.createTrackbar('SMax','image',0,255,nothing)",
				"cv2.createTrackbar('VMax','image',0,255,nothing)",
				"",
				"# Set default value for MAX HSV trackbars.",
				"cv2.setTrackbarPos('HMax', 'image', 179)",
				"cv2.setTrackbarPos('SMax', 'image', 255)",
				"cv2.setTrackbarPos('VMax', 'image', 255)",
				"",
				"# Initialize to check if HSV min/max value changes",
				"hMin = sMin = vMin = hMax = sMax = vMax = 0",
				"phMin = psMin = pvMin = phMax = psMax = pvMax = 0",
				"",
				"img = cv2.imread('D:\/untitled.png')",
				"output = img",
				"waitTime = 33",
				"",
				"while(1):",
				"",
				"    # get current positions of all trackbars",
				"    hMin = cv2.getTrackbarPos('HMin','image')",
				"    sMin = cv2.getTrackbarPos('SMin','image')",
				"    vMin = cv2.getTrackbarPos('VMin','image')",
				"",
				"    hMax = cv2.getTrackbarPos('HMax','image')",
				"    sMax = cv2.getTrackbarPos('SMax','image')",
				"    vMax = cv2.getTrackbarPos('VMax','image')",
				"",
				"    # Set minimum and max HSV values to display",
				"    lower = np.array([hMin, sMin, vMin])",
				"    upper = np.array([hMax, sMax, vMax])",
				"",
				"    # Create HSV Image and threshold into a range.",
				"    hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)",
				"    mask = cv2.inRange(hsv, lower, upper)",
				"    output = cv2.bitwise_and(img,img, mask= mask)",
				"",
				"    # Print if there is a change in HSV value",
				"    if( (phMin != hMin) | (psMin != sMin) | (pvMin != vMin) | (phMax != hMax) | (psMax != sMax) | (pvMax != vMax) ):",
				"        print('(hMin = %d , sMin = %d, vMin = %d), (hMax = %d , sMax = %d, vMax = %d)' % (hMin , sMin , vMin, hMax, sMax , vMax))",
				"        phMin = hMin",
				"        psMin = sMin",
				"        pvMin = vMin",
				"        phMax = hMax",
				"        psMax = sMax",
				"        pvMax = vMax",
				"",
				"    # Display output image",
				"    cv2.imshow('image',output)",
				"",
				"    # Wait longer to prevent freeze for videos.",
				"    if cv2.waitKey(waitTime) & 0xFF == ord('q'):",
				"        break",
				"",
				"cv2.destroyAllWindows()"
		],
		"description":"색 범위 지정 기능입니다."
	},
	"pytorch_1_regression_user_code_snippet":{
		"prefix":"pytorch_1_regression_user_code_snippet",
		"body":[
				"# %%",
				"# 패키지 불러오기",
				"import torch",
				"import torch.nn as nn",
				"from torch.utils.data import Dataset, DataLoader",
				"from sklearn.model_selection import train_test_split",
				"",
				"",
				"# 데이터셋",
				"class MyDataset(Dataset):",
				"    def __init__(self, X, y):",
				"        self.X = X",
				"        self.y = y",
				"",
				"    def __len__(self):",
				"        return len(self.X)",
				"",
				"    def __getitem__(self, idx):",
				"        return self.X[idx], self.y[idx]",
				"",
				"",
				"# 훈련 메서드",
				"def train(model, X_train, y_train, loss_function):",
				"    train_loader = DataLoader(",
				"        dataset=MyDataset(X_train, y_train), batch_size=BATCH_SIZE",
				"    )",
				"    optimizer = torch.optim.Adam(model.parameters())",
				"    for epoch in range(EPOCHS):",
				"        for X, y in train_loader:",
				"            optimizer.zero_grad()",
				"            loss = loss_function(model(X), y)",
				"            loss.backward()",
				"            optimizer.step()",
				"",
				"        # print loss",
				"        if epoch % 100 == 0:",
				"            print(f'Epoch {epoch}, Loss: {loss.data}')",
				"    return model",
				"",
				"",
				"# 이 위까지는 공통 활용 코드로 수정 불필요",
				"###########################################################################################",
				"# %%",
				"# 하이퍼파라미터",
				"LEARNING_RATE = 0.02",
				"BATCH_SIZE = 2",
				"HIDDEN_FEATURES = 20",
				"EPOCHS = 200",
				"",
				"# %%",
				"# 데이터 준비",
				"from sklearn.datasets import make_regression",
				"",
				"X, y = make_regression(n_samples=200, n_features=5, noise=1, random_state=42)",
				"X = torch.FloatTensor(X)",
				"y = torch.FloatTensor(y.reshape(-1, 1))  # y.shape = (200,) 에서 (200, 1) 형태의 2차원 배열로 변경",
				"",
				"",
				"# %%",
				"# 모델 선언",
				"class RegressionNetwork(nn.Module):",
				"    def __init__(self, input_features, hidden_features, output_features):",
				"        super(RegressionNetwork, self).__init__()",
				"        self.linear = nn.Linear(input_features, hidden_features)",
				"        self.linear_2 = nn.Linear(hidden_features, output_features)",
				"",
				"    def forward(self, x):",
				"        x = self.linear(x)",
				"        x = self.linear_2(x)",
				"        return x",
				"",
				"",
				"model = RegressionNetwork(",
				"    input_features=X.shape[1] if len(X.shape) != 1 else 1,",
				"    hidden_features=HIDDEN_FEATURES,",
				"    output_features=y.shape[1] if len(y.shape) != 1 else 1,",
				")",
				"",
				"# %%",
				"# 학습",
				"X_train, X_test, y_train, y_test = train_test_split(X, y)",
				"loss_function = nn.MSELoss()",
				"model = train(",
				"    model,",
				"    X_train,",
				"    y_train,",
				"    loss_function",
				")",
				"",
				"# %%",
				"# 모델 저장 및 불러오기",
				"torch.save(model.state_dict(), 'my_model.pth')",
				"model = RegressionNetwork(",
				"    input_features=X.shape[1] if len(X.shape) != 1 else 1,",
				"    hidden_features=HIDDEN_FEATURES,",
				"    output_features=y.shape[1] if len(y.shape) != 1 else 1,",
				")",
				"model.load_state_dict(torch.load('my_model.pth'))",
				"",
				"# %%",
				"# 예측",
				"from sklearn.metrics import r2_score",
				"",
				"with torch.no_grad():",
				"    y_pred = model(X_test)",
				"    score = r2_score(y_test, y_pred)",
				"    print(f'Test score{r2_score}: {score * 100}%')"
		],
		"description":"파이토치 기본 코드입니다."
	},
	"logging_1_log_basic_user_code_snippet":{
		"prefix":"logging_1_log_basic_user_code_snippet",
		"body":[
				"# https://hwangheek.github.io/2019/python-logging/",
				"import logging",
				"",
				"def get_config(filename='log'):",
				"    logger_config = {",
				"        'version': 1,",
				"        'disable_existing_loggers': False,",
				"        'formatters': {",
				"            'basic': {'format': '%(asctime)s - %(name)s - %(levelname)8s - %(message)s'}",
				"        },",
				"        'handlers': {",
				"            'console': {",
				"                'class': 'logging.StreamHandler',",
				"                'level': 'DEBUG',",
				"                'formatter': 'basic',",
				"            },",
				"            'file_debug': {",
				"                'class': 'logging.FileHandler',",
				"                'level': 'DEBUG',",
				"                'formatter': 'basic',",
				"                'filename': f'{filename}_debug.log',",
				"            },",
				"            'file_error': {",
				"                'class': 'logging.FileHandler',",
				"                'level': 'ERROR',",
				"                'formatter': 'basic',",
				"                'filename': f'{filename}_error.log',",
				"            },",
				"        },",
				"        'loggers': {",
				"            '__main__': {",
				"                'level': 'DEBUG',",
				"                'handlers': ['console', 'file_debug', 'file_error'],",
				"                'propagate': True,",
				"            }",
				"        },",
				"    }",
				"    return logger_config",
				"",
				"logger_name = 'log'",
				"logging.config.dictConfig(get_config(logger_name))",
				"logger = logging.getLogger(__name__)",
				"logger.debug('1. debug level log')",
				"logger.info('2. info level log')",
				"logger.warning('3. warning level log')",
				"logger.error('4. error level log')",
				"logger.critical('5. critical level log')"
		],
		"description":"로깅 기본 코드입니다."
	},
	"pytorch_2_classification_basic_user_code_snippet":{
		"prefix":"pytorch_2_classification_basic_user_code_snippet",
		"body":[
				"# %%",
				"# 패키지 불러오기",
				"import torch",
				"import torch.nn as nn",
				"from torch.utils.data import Dataset, DataLoader",
				"from sklearn.model_selection import train_test_split",
				"",
				"",
				"# 데이터셋",
				"class MyDataset(Dataset):",
				"    def __init__(self, X, y):",
				"        self.X = X",
				"        self.y = y",
				"",
				"    def __len__(self):",
				"        return len(self.X)",
				"",
				"    def __getitem__(self, idx):",
				"        return self.X[idx], self.y[idx]",
				"",
				"",
				"# 훈련 메서드",
				"def train(model, X_train, y_train, loss_function):",
				"    train_loader = DataLoader(",
				"        dataset=MyDataset(X_train, y_train), batch_size=BATCH_SIZE",
				"    )",
				"    optimizer = torch.optim.Adam(model.parameters())",
				"    for epoch in range(EPOCHS):",
				"        for X, y in train_loader:",
				"            optimizer.zero_grad()",
				"            loss = loss_function(model(X), y)",
				"            loss.backward()",
				"            optimizer.step()",
				"",
				"        # print loss",
				"        if epoch % 100 == 0:",
				"            print(f'Epoch {epoch}, Loss: {loss.data}')",
				"    return model",
				"",
				"",
				"# 이 위까지는 공통 활용 코드로 수정 불필요",
				"###########################################################################################",
				"# %%",
				"# 하이퍼파라미터",
				"BATCH_SIZE = 32",
				"HIDDEN_FEATURES = 6",
				"LEARNING_RATE = 0.02",
				"EPOCHS = 100",
				"",
				"# %%",
				"# 데이터 준비",
				"# y값 : nn.CrossEntropyLoss에 적용하려면 y.shape가 (N, )처럼 1차원 리스트여야 함. 2차원이면 안 됨.",
				"# y값 : LongTensor 타입이여야 손실 함수 연산 가능.",
				"from sklearn.datasets import load_iris",
				"",
				"iris = load_iris()",
				"X = torch.FloatTensor(iris.data)",
				"y = torch.LongTensor(iris.target)",
				"X_train, X_test, y_train, y_test = train_test_split(X, y)",
				"",
				"",
				"# %%",
				"# 모델 선언",
				"class MultiClassNetwork(nn.Module):",
				"    def __init__(self, NUM_FEATURES, NUM_CLASSES, HIDDEN_FEATURES):",
				"        super().__init__()",
				"        self.lin1 = nn.Linear(NUM_FEATURES, HIDDEN_FEATURES)",
				"        self.lin2 = nn.Linear(HIDDEN_FEATURES, NUM_CLASSES)",
				"        self.log_softmax = nn.LogSoftmax(dim=1)",
				"",
				"    def forward(self, x):",
				"        x = self.lin1(x)",
				"        x = torch.sigmoid(x)",
				"        x = self.lin2(x)",
				"        x = self.log_softmax(x)",
				"        return x",
				"",
				"",
				"model = MultiClassNetwork(",
				"    NUM_FEATURES=X.shape[1] if len(X.shape) != 1 else 1,",
				"    NUM_CLASSES=len(torch.unique(y)),",
				"    HIDDEN_FEATURES=HIDDEN_FEATURES,",
				")",
				"",
				"# %%",
				"# 학습",
				"train(model, X_train, y_train, loss_function := nn.CrossEntropyLoss())",
				"# %%",
				"# 모델 저장 및 불러오기",
				"torch.save(model.state_dict(), 'my_model.pth')",
				"model = MultiClassNetwork(",
				"    NUM_FEATURES=X.shape[1] if len(X.shape) != 1 else 1,",
				"    NUM_CLASSES=len(torch.unique(y)),",
				"    HIDDEN_FEATURES=HIDDEN_FEATURES,",
				")",
				"model.load_state_dict(torch.load('my_model.pth'))",
				"# %%",
				"# 예측",
				"from sklearn.metrics import accuracy_score",
				"",
				"with torch.no_grad():",
				"    y_test_hat_softmax = model(X_test)",
				"    y_test_hat = torch.max(y_test_hat_softmax.data, 1)  # 가장 확률 높은 클래스 선택",
				"print(accuracy_score(y_test, y_test_hat.indices))"
		],
		"description":"pytorch 분류기 기본 코드입니다."
	},
	"moviepy_1_user_code_snippet":{
		"prefix":"moviepy_1_user_code_snippet",
		"body":[
				"from moviepy.editor import *",
				"",
				"filename = 'video.mp4'",
				"clip = VideoFileClip(filename)",
				"clip = clip.subclip(0, 5)  # 0~5초 구간만 남기기",
				"clip = clip.fx(vfx.speedx, 3)  # 3배속",
				"clip.write_videofile('result_mp4.mp4')",
				"clip.ipython_display()"
		],
		"description":"moviepy 영상 자르기, 배속 코드입니다."
	},
	"pathlib_1_download_user_code_snippet":{
		"prefix":"pathlib_1_download_user_code_snippet",
		"body":[
			"from pathlib import Path",
			"import requests",
			"image_url = 'https://www.google.com/images/branding/googlelogo/1x/googlelogo_color_272x92dp.png'",
			"filename = 'result.png'",
			"Path(filename).write_bytes(requests.get(image_url).content)"
		],
		"description":"pathlib 활용한 간소화된 다운로드 코드입니다."
	},
	"pytorch_3_image_classfication_basic_user_code_snippet":{
		"prefix":"pytorch_3_image_classfication_basic_user_code_snippet",
		"body":[
				"# %%",
				"# 패키지 불러오기",
				"import torch",
				"import torch.nn as nn",
				"from torch.utils.data import Dataset, DataLoader",
				"from sklearn.model_selection import train_test_split",
				"",
				"",
				"# 데이터셋",
				"class MyDataset(Dataset):",
				"    def __init__(self, X, y):",
				"        self.X = X",
				"        self.y = y",
				"",
				"    def __len__(self):",
				"        return len(self.X)",
				"",
				"    def __getitem__(self, idx):",
				"        return self.X[idx], self.y[idx]",
				"",
				"",
				"# 훈련 메서드",
				"def train(model, X_train, y_train, loss_function):",
				"    train_loader = DataLoader(",
				"        dataset=MyDataset(X_train, y_train), batch_size=BATCH_SIZE",
				"    )",
				"    optimizer = torch.optim.Adam(model.parameters())",
				"    for epoch in range(EPOCHS):",
				"        for X, y in train_loader:",
				"            optimizer.zero_grad()",
				"            loss = loss_function(model(X), y)",
				"            loss.backward()",
				"            optimizer.step()",
				"",
				"        # print loss",
				"        if epoch % 100 == 0:",
				"            print(f'Epoch {epoch}, Loss: {loss.data}')",
				"    return model",
				"",
				"",
				"# 이 위까지는 공통 활용 코드로 수정 불필요",
				"###########################################################################################",
				"# %%",
				"# 하이퍼파라미터",
				"BATCH_SIZE = 4",
				"HIDDEN_FEATURES = 6",
				"LEARNING_RATE = 0.02",
				"EPOCHS = 10",
				"",
				"# %%",
				"# 데이터 준비",
				"import torchvision",
				"import torchvision.transforms as transforms",
				"import numpy as np",
				"",
				"transform = transforms.Compose(",
				"    [",
				"        transforms.Resize(32),",
				"        transforms.Grayscale(num_output_channels=1),",
				"        transforms.ToTensor(),",
				"        transforms.Normalize((0.5,), (0.5,)),",
				"    ]",
				")",
				"trainset = torchvision.datasets.ImageFolder(root='data/train', transform=transform)",
				"X_train = [data[0] for data in trainset]",
				"y_train = np.array(trainset.targets).astype(float)  # nn.BCELoss()의 y 값은 실수형이어야 함.",
				"testset = torchvision.datasets.ImageFolder(root='data/test', transform=transform)",
				"X_test = [data[0] for data in testset]",
				"y_test = np.array(testset.targets).astype(float)  # nn.BCELoss()의 y 값은 실수형이어야 함.",
				"",
				"",
				"# %%",
				"# 모델 선언",
				"class ImageClassificationNet(nn.Module):",
				"    def __init__(self) -&gt; None:",
				"        super().__init__()",
				"        self.conv1 = nn.Conv2d(1, 6, 3)",
				"        self.pool = nn.MaxPool2d(2, 2)",
				"        self.conv2 = nn.Conv2d(6, 16, 3)",
				"        self.fc1 = nn.Linear(16 * 6 * 6, 128)",
				"        self.fc2 = nn.Linear(128, 64)",
				"        self.fc3 = nn.Linear(64, 1)",
				"        self.relu = nn.ReLU()",
				"        self.sigmoid = nn.Sigmoid()",
				"",
				"    def forward(self, x):",
				"        x = self.conv1(x)",
				"        x = self.relu(x)",
				"        x = self.pool(x)",
				"        x = self.conv2(x)",
				"        x = self.relu(x)",
				"        x = self.pool(x)",
				"        x = torch.flatten(x, 1)",
				"        x = self.fc1(x)",
				"        x = self.relu(x)",
				"        x = self.fc2(x)",
				"        x = self.relu(x)",
				"        x = self.fc3(x)",
				"        x = self.sigmoid(x)",
				"        return x.squeeze().double()",
				"",
				"",
				"model = ImageClassificationNet()",
				"",
				"# %%",
				"# 학습",
				"train(model, X_train, y_train, loss_function := nn.BCELoss())",
				"# %%",
				"# 모델 저장 및 불러오기",
				"torch.save(model.state_dict(), 'my_model.pth')",
				"model = ImageClassificationNet()",
				"model.load_state_dict(torch.load('my_model.pth'))",
				"",
				"# %%",
				"# 예측",
				"from sklearn.metrics import accuracy_score",
				"",
				"test_loader = DataLoader(dataset=MyDataset(X_test, y_test), batch_size=BATCH_SIZE)",
				"y_pred = []",
				"model.eval()",
				"with torch.no_grad():",
				"    for X, y in test_loader:",
				"        y_pred.extend(model(X).round())  # 이진 값으로 만들기 위해 반올림(round)",
				"",
				"score = accuracy_score(y_test, y_pred)",
				"print(f'Test score{accuracy_score}: {score * 100}%')"
		],
		"description":"이미지 분류 코드입니다."
	},
	"pytorch_4_loss_function_user_code_snippet":{
		"prefix":"pytorch_4_loss_function_user_code_snippet",
		"body":[
			"import pandas as pd",
			"pd.set_option('display.max_colwidth', None)",
			"pytorch_metadata = pd.DataFrame(columns=['모델','설명','출력층','손실함수', '스코어링','X예시', 'y예시'])",
			"pytorch_metadata.loc[len(pytorch_metadata)] = ['회귀', '회귀','nn.Linear()','nn.MSELoss()(x,y)', 'r2_score(x,y)','torch.FloatTensor([1,2,3])','torch.FloatTensor([4,5,6])',]",
			"pytorch_metadata.loc[len(pytorch_metadata)] = ['분류 - 이진', 'nn.BCEWithLogitsLoss() 쓰자. nn.Sigmoid() + nn.BCELoss() = nn.BCEWithLogitsLoss()임. 즉 nn.BCEWithLogitsLoss() 쓰면 코드가 간결해짐.','nn.Sigmoid()','nn.BCELoss()(x,y)', 'accuracy_score(x,y)','0,1만 됨 torch.FloatTensor([1,0,1])','0,1만 됨 torch.FloatTensor([1,1,1])']",
			"pytorch_metadata.loc[len(pytorch_metadata)] = ['분류 - 멀티클래스','CrossEntropyLoss는 출력에 nn.Softmax() 적용해줌. 즉 코드에 nn.Softmax() 넣을 필요 없음.', 'nn.Linear()','nn.CrossEntropyLoss()(x,y)', 'accuracy_score(x,y)','torch.FloatTensor([1,2,3])','torch.FloatTensor([4,5,6])']",
			"pytorch_metadata.loc[len(pytorch_metadata)] = ['분류 - 멀티레이블', 'WithLogits이므로 알아서 Sigmoid 연산 해 줌. 문제는, 스코어링 할 때는 sigmoid + round 안 쓰면 연산이 안 된다는 거임.','nn.Linear()','nn.BCEWithLogitsLoss()(x,y)', 'accuracy_score(y, nn.Sigmoid()(model(x)).round())','torch.FloatTensor([1,2,3])','torch.FloatTensor([4,5,6])']",
			"pytorch_metadata"
		],
		"description":"pytorch에서 모델별 사용하는 손실함수 및 스코어링 함수입니다."
	},
	"youtube_downloader_1_mp3_user_code_snippet":{
		"prefix":"youtube_downloader_1_mp3_user_code_snippet",
		"body":[
			"from yt_dlp import YoutubeDL # 의존성 체크용",
			"import subprocess",
			"import sys",
			"",
			"# MP3 다운로드",
			"# python -u -m yt_dlp --extract-audio --audio-format mp3 --audio-quality 0 https://www.youtube.com/watch?v=KQetemT1sWc",
			"# -u : 출력 스트림을 버퍼에 쌓아두지 않고(unbuffered) 바로 출력합니다. 파이썬 스크립트에서 실시간 출력을 위해 설정합니다.",
			"# -m : 라이브러리 모듈을 스크립트로 실행합니다. 달리 말하면 if __name__ == '__main__': 이하 부분을 실행합니다.",
			"",
			"# yt_dlp : 커맨드라인에선 yt-dlp이지만, 모듈을 부르므로 언더바(_)로 써야 합니다.",
			"# 참고 : python이 PATH에 속한 경우 yt-dlp를 써도 됩니다. 그러나 anaconda 가상 환경인 경우에도 작동을 보장하기 위해 python -m을 통해 모듈을 호출합니다.",
			"# --extract-audio --audio-format mp3 : mp3 다운로드",
			"# --audio-quality 0 : 최고 퀄리티. 최저 퀄리티가 10",
			"# --paths D:\\ : D드라이브에 다운로드",
			"",
			"# python -u -m yt_dlp --extract-audio --audio-format mp3 --audio-quality 0 https://www.youtube.com/watch?v=KQetemT1sWc --paths D:/",
			"output = subprocess.Popen([sys.executable, '-u', '-m'] + f'yt_dlp --extract-audio --audio-format mp3 --audio-quality 0 https://www.youtube.com/watch?v=KQetemT1sWc --paths D:/'.split(' '),",
			"                        stdout=subprocess.PIPE, ",
			"                        stderr=subprocess.STDOUT, # stdout에 오류도 함께 출력",
			"                        universal_newlines=True, # True일 경우 출력이 str 타입, False일 경우 바이트 타입",
			")",
			"",
			"# 실시간 출력",
			"while output.poll() == None:",
			"    out = output.stdout.readline()",
			"    print(out, end='')"
		],
		"description":"youtube downloader 스크립트에서 사용하는 코드입니다."
	},
	"plotly_2_save_load_figure_user_code_snippet":{
		"prefix":"plotly_2_save_load_figure_user_code_snippet",
		"body":[
			"# %%",
			"# plotly figure를 파일로 저장하고 불러오는 코드입니다.",
			"# https://github.com/plotly/plotly.py/issues/579#issuecomment-398368657",
			"import json",
			"from plotly.utils import PlotlyJSONEncoder",
			"import plotly.graph_objs as go",
			"",
			"",
			"def save_fig(fig, filename):",
			"    data = json.loads(json.dumps(fig.data, cls=PlotlyJSONEncoder))",
			"    layout = json.loads(json.dumps(fig.layout, cls=PlotlyJSONEncoder))",
			"    with open(filename, 'w') as f:",
			"        f.write(json.dumps({'data': data, 'layout': layout}))",
			"",
			"",
			"def load_fig(fpath):",
			"    with open(fpath, 'r') as f:",
			"        v = json.loads(f.read())",
			"        fig = go.Figure(data=v['data'], layout=v['layout'])",
			"        return fig",
			"",
			"",
			"trace = go.Scatter(x=[i for i in range(5000)], y=[i**2 for i in range(5000)])",
			"fig = go.Figure(data=[trace])",
			"save_fig(fig, 'myfile.json')",
			"fig_from_file = load_fig('myfile.json')",
			"fig_from_file.show()"
		],
		"description":"figure 객체를 저장하고 불러오는 코드입니다."
	},
	"selenium_1_basic_user_code_snippet":{
		"prefix":"selenium_1_basic_user_code_snippet",
		"body":[
			"# %%",
			"# 셀레니움 코드입니다.",
			"# %%",
			"# 모듈 불러오기",
			"def install_dependencies():",
			"    '''셀레니움 설치'''",
			"    import subprocess",
			"    import sys",
			"",
			"    INSTALL_COMMAND = '-m pip --trusted-host pypi.org --trusted-host files.pythonhosted.org install --no-cache-dir --force-reinstall'",
			"    PACKAGES = 'selenium webdriver_manager'",
			"    subprocess.run([sys.executable, *INSTALL_COMMAND.split(' '), *PACKAGES.split(' ')])",
			"",
			"",
			"try:",
			"    import re",
			"    import selenium",
			"    import webdriver_manager",
			"except ModuleNotFoundError:",
			"    install_dependencies()",
			"finally:",
			"    # 작업에 사용되는 패키지 불러오기",
			"    from selenium.webdriver.common.by import By",
			"    from selenium.webdriver.support.ui import WebDriverWait",
			"    from selenium.webdriver.support import expected_conditions as EC",
			"",
			"",
			"# %%",
			"# 드라이버 준비",
			"def get_webdriver():",
			"    '''크롬 드라이버를 다운로드하고 웹드라이버로 불러옵니다.",
			"",
			"    Returns:",
			"        selenium.webdriver: 셀레니움 웹드라이버입니다.",
			"    '''",
			"    from selenium import webdriver",
			"    from selenium.webdriver.chrome.service import Service as ChromeService",
			"    from webdriver_manager.chrome import ChromeDriverManager",
			"    import os",
			"",
			"    os.environ['WDM_SSL_VERIFY'] = '0'",
			"",
			"    driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()))",
			"    return driver",
			"",
			"",
			"def click(driver, query):",
			"    '''객체를 클릭합니다.",
			"",
			"    Args:",
			"        driver (selenium.webdriver): 셀레니움 웹드라이버입니다.",
			"        query (str): 쿼리입니다.",
			"",
			"    Example:",
			"        click(driver, '#logoImage')",
			"        click(driver, '/html/body/div')",
			"    '''",
			"    attribute = None",
			"    if query.startswith('#'):",
			"        attribute = By.CSS_SELECTOR",
			"    elif query.startswith('/html'):",
			"        attribute = By.XPATH",
			"    assert (",
			"        attribute is not None",
			"    ), '쿼리는 반드시 selector 혹은 xpath여야 합니다. 예) #name, /html/body/div[1]'",
			"",
			"    wait = WebDriverWait(driver, 10)",
			"    wait.until(EC.element_to_be_clickable((attribute, query))).click()",
			"",
			"",
			"def write(driver, query, content):",
			"    '''객체에 내용을 입력합니다.",
			"",
			"    Args:",
			"        driver (selenium.webdriver): 셀레니움 웹드라이버입니다.",
			"        query (str): 쿼리입니다.",
			"        content (str): 입력할 내용입니다.",
			"",
			"    Example:",
			"        write(driver, '#logoImage', 'hello world')",
			"        write(driver, '/html/body/div', 'text')",
			"    '''",
			"    attribute = None",
			"    if query.startswith('#'):",
			"        attribute = By.CSS_SELECTOR",
			"    elif query.startswith('/html'):",
			"        attribute = By.XPATH",
			"    assert (",
			"        attribute is not None",
			"    ), '쿼리는 반드시 selector 혹은 xpath여야 합니다. 예) #name, /html/body/div[1]'",
			"    driver.find_element(attribute, query).send_keys(content)",
			"",
			"",
			"def ok_alert(driver):",
			"    '''팝업창을 클릭합니다.",
			"",
			"    Args:",
			"        driver (selenium.webdriver): 셀레니움 웹드라이버입니다.",
			"    '''",
			"    WebDriverWait(driver, 20).until(EC.alert_is_present())",
			"    driver.switch_to.alert.accept()",
			"    return",
			"",
			"",
			"def remove(driver, query):",
			"    '''객체를 adblock 기능처럼 삭제합니다.",
			"",
			"    Args:",
			"        driver (selenium.webdriver): 셀레니움 웹드라이버입니다.",
			"        query (str): 쿼리입니다.",
			"",
			"    Example:",
			"        remove(driver, '#logoImage')",
			"    '''",
			"    attribute = None",
			"    if query.startswith('#'):",
			"        attribute = By.CSS_SELECTOR",
			"    elif query.startswith('/html'):",
			"        attribute = By.XPATH",
			"    assert (",
			"        attribute is not None",
			"    ), '쿼리는 반드시 selector 혹은 xpath여야 합니다. 예) #name, /html/body/div[1]'",
			"",
			"    wait = WebDriverWait(driver, 10)",
			"    element = wait.until(EC.presence_of_element_located((attribute, query)))",
			"    driver.execute_script('arguments[0].removeAttribute(\"style\")', element)",
			"",
			"",
			"# %%",
			"# 유저 입력 받기",
			"import tkinter as tk",
			"from tkinter import simpledialog",
			"",
			"# topmost 설정이 있어야 vscode 환경에서 가장 위에 다이얼로그가 출력됨.",
			"root = tk.Tk()",
			"root.withdraw()",
			"root.attributes('-topmost', True)",
			"user_id = simpledialog.askstring('ID', '로그인 ID 입력', parent=root)",
			"user_pw = simpledialog.askstring('PW', '로그인 PW 입력', show='*', parent=root)",
			"",
			"",
			"# %%",
			"# 로그인",
			"driver = get_webdriver()",
			"driver.get('https://www.google.com/')",
			"write(driver,",
			"      text:='/html/body/div[1]/div[3]/form/div[1]/div[1]/div[1]/div/div[2]/textarea',",
			"      'google',)",
			"click(driver,",
			"      search_button:='/html/body/div[1]/div[3]/form/div[1]/div[1]/div[4]/center/input[1]')"
		],
		"description":"selenium 기본 코드입니다."
	},
	"asyncio_1_as_completed_user_code_snippet":{
		"prefix":"asyncio_1_as_completed_user_code_snippet",
		"body":[
				"# https://superfastpython.com/asyncio-as_completed/",
				"",
				"import asyncio",
				"import random",
				"",
				"async def task_coro(arg):",
				"    # generate a random value between 0 and 1",
				"    value = random.random()",
				"    print(str(value) + ' sleep!')",
				"    await asyncio.sleep(value)",
				"    return value",
				"",
				"async def main():",
				"    coros = [task_coro(i) for i in range(10)]",
				"    # get results as coroutines are completed",
				"    for coro in asyncio.as_completed(coros):",
				"        result = await coro",
				"        print(f'got {result}')",
				"",
				"asyncio.run(main())"
		],
		"description":"비동기로 실행하고 개별 task가 완료될 때마다 값을 출력하는 코드입니다."
	},
	"plotly_2_3d_user_code_snippet":{
		"prefix":"plotly_2_3d_user_code_snippet",
		"body":[
				"# %%",
				"# 3d plot 코드입니다.",
				"import plotly.graph_objects as go",
				"import numpy as np",
				"",
				"x = [1 for _ in range(100)]",
				"x2 = [2 for _ in range(100)]",
				"x3 = [3 for _ in range(100)]",
				"x4 = [4 for _ in range(100)]",
				"y = [i for i in range(100)]",
				"z = [np.exp(-i * 0.1) for i in range(100)]",
				"z2 = [np.exp(-i * 0.1) for i in range(100)]",
				"z2[50:] = [np.nan] * 50",
				"",
				"fig = go.Figure()",
				"fig.add_trace(go.Scatter3d(x=x, y=y, z=z))",
				"fig.add_trace(go.Scatter3d(x=x2, y=y, z=z, mode='lines'))",
				"fig.add_trace(",
				"    go.Scatter3d(",
				"        x=x2,",
				"        y=y,",
				"        z=z2,",
				"        mode='lines',",
				"        line=dict(color='skyblue', width=5),",
				"    )",
				")",
				"fig.add_trace(go.Scatter3d(x=x3, y=y, z=z, mode='markers'))",
				"fig.add_trace(go.Scatter3d(x=x4, y=y, z=z, mode='lines+markers'))",
				"fig.show()"
		],
		"description":"plotly 3d 차트입니다."
	},
	"matplotlib_1_3d_subplots_user_code_snippet":{
		"prefix":"matplotlib_1_3d_subplots_user_code_snippet",
		"body":[
				"# %%",
				"# matplotlib 3d 차트입니다.",
				"import matplotlib.pyplot as plt",
				"import numpy as np",
				"",
				"x = [1 for _ in range(100)]",
				"x2 = [2 for _ in range(100)]",
				"x3 = [3 for _ in range(100)]",
				"x4 = [4 for _ in range(100)]",
				"y = [i for i in range(100)]",
				"z = [np.exp(-i * 0.1) for i in range(100)]",
				"z2 = [np.exp(-i * 0.1) for i in range(100)]",
				"z2[50:] = [np.nan] * 50",
				"",
				"fig = plt.figure()",
				"ax = fig.add_subplot(111, projection='3d')",
				"",
				"ax.plot(x, y, z, label='x=1')",
				"ax.plot(x2, y, z, label='x=2')",
				"ax.plot(x2, y, z2, label='x=2, partial')",
				"ax.plot(x3, y, z, label='x=3')",
				"ax.plot(x4, y, z, label='x=4')",
				"",
				"ax.set_xlabel('X')",
				"ax.set_ylabel('Y')",
				"ax.set_zlabel('Z')",
				"ax.legend()",
				"",
				"plt.show()"
		],
		"description":"matplotlib 3d 차트입니다."
	},
	"sqlite_1_db_user_code_snippet":{
		"prefix":"sqlite_1_db_user_code_snippet",
		"body":[
				"# %%",
				"# insert df to DB",
				"",
				"import pandas as pd",
				"import sqlite3",
				"",
				"database_name = 'my_database.db'",
				"table_name = 'my_table'",
				"connection = sqlite3.connect(database_name)",
				"data = {'text': ['A', 'B'], 'number': [1, 2]}",
				"df = pd.DataFrame(data)",
				"df.to_sql(table_name, connection, if_exists='append', index=False)",
				"connection.close()",
				"",
				"# %%",
				"# insert dictionary to DB",
				"record = {'text': 'C', 'number': 3}",
				"insert_query = f'''INSERT INTO my_table (text, number) VALUES ('{record['text']}', {record['number']})'''",
				"connection = sqlite3.connect(database_name)",
				"connection.execute(insert_query)",
				"connection.commit()",
				"connection.close()",
				"",
				"# %%",
				"# read DB to df",
				"with sqlite3.connect(database_name) as connection:",
				"    select_query = '''SELECT * FROM my_table'''",
				"    df2 = pd.read_sql_query(select_query, connection)",
				"df2"
		],
		"description":"sqlite3 및 pandas 활용 DB 읽기, 쓰기 코드입니다."
	},
	"cv2_1_video_save_user_code_snippet":{
		"prefix":"cv2_1_video_save_user_code_snippet",
		"body":[
				"import cv2",
				"import datetime",
				"import time",
				"import sys",
				"from pathlib import Path",
				"",
				"VIDEO_DIRECTORY = Path(sys.path[0] + '/rtsp_video')",
				"VIDEO_DIRECTORY.mkdir(parents=True, exist_ok=True)",
				"CODEC = cv2.VideoWriter_fourcc(*'DIVX')",
				"",
				"path = 'rtsp://127.0.0.1:554'",
				"",
				"def download_rtsp(path, seconds=60, width=None, height=None):",
				"    cap = cv2.VideoCapture(path)",
				"    original_width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))",
				"    original_height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))",
				"    need_resize = False",
				"    if width:",
				"        if width != original_width:",
				"            need_resize = True",
				"    else:",
				"        width = original_width",
				"",
				"    if height:",
				"        if height != original_height:",
				"            need_resize = True",
				"    else:",
				"        height = original_height",
				"",
				"    if not width:",
				"        width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))",
				"    if not height:",
				"        height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))",
				"    fps = cap.get(cv2.CAP_PROP_FPS)",
				"    print(f'영상 정보 : 사이즈 ({width}*{height}), fps {fps}')",
				"",
				"    start = time.time()",
				"    file_path = VIDEO_DIRECTORY / Path(",
				"        datetime.datetime.now().strftime('%Y%m%d-%H%M%S') + '.avi'",
				"    )",
				"    out = cv2.VideoWriter(file_path.as_posix(), CODEC, fps, (width, height))",
				"    while cap.isOpened():",
				"        frame_available, frame = cap.read()",
				"        if not frame_available:",
				"            print('프레임을 읽어올 수 없으므로 종료합니다.')",
				"            break",
				"        if need_resize:",
				"            frame = cv2.resize(frame, (width, height))",
				"        if time.time() - start &gt; seconds:",
				"            print(f'{file_path.as_posix()} 저장 완료')",
				"            start = time.time()",
				"            file_path = VIDEO_DIRECTORY / Path(",
				"                datetime.datetime.now().strftime('%Y%m%d_%H%M%S') + '.avi'",
				"            )",
				"            print(f'새 파일인 {file_path}에 영상 녹화 시작')",
				"            out = cv2.VideoWriter(file_path.as_posix(), CODEC, fps, (width, height))",
				"        out.write(frame)",
				"",
				"        if cv2.waitKey(1) & 0xFF == ord('q'):",
				"            break",
				"    cap.release()",
				"    cv2.destroyAllWindows()",
				"",
				"",
				"download_rtsp(path, seconds=10, width=640, height=480)"
		],
		"description":"실시간 영상을 저장합니다."
	},
	"dash_6_extendData_clientside_user_code_snippet":{
		"prefix":"dash_6_extendData_clientside_user_code_snippet",
		"body":[
				"# 클라이언트 사이드 콜백을 활용한 extendData 애니메이션입니다.",
				"from dash import Dash, dcc, html, Input, Output, clientside_callback, State",
				"import pandas as pd",
				"import numpy as np",
				"",
				"df = pd.DataFrame(",
				"    {",
				"        'x': [i for i in range(10000)],",
				"        'phase_1': [np.sin(4 * np.pi * i * 0.01) for i in range(10000)],",
				"        'phase_2': [",
				"            np.sin(4 * np.pi * i * 0.01 - 2 * (np.pi) / 3) for i in range(10000)",
				"        ],",
				"        'phase_3': [np.sin(4 * np.pi * i * 0.01 - (np.pi) / 3) for i in range(10000)],",
				"    }",
				")",
				"figure = dict(  # 이게 선언이 안 되면 extendData 작동 안 함.",
				"    data=[",
				"        {'x': [], 'y': []},",
				"        {'x': [], 'y': []},",
				"        {'x': [], 'y': []},",
				"    ],",
				")",
				"app = Dash(__name__)",
				"app.layout = html.Div(",
				"    [",
				"        dcc.Graph(id='clientside-graph', figure=figure),",
				"        dcc.Interval(id='interval', interval=40),",
				"        dcc.Store(id='sin_wave', data=df.to_dict('list')),",
				"    ]",
				")",
				"clientside_callback(",
				"    '''",
				"    function(n_intervals, data) {",
				"        var x = [",
				"            [n_intervals],",
				"            [n_intervals],",
				"            [n_intervals],",
				"        ];",
				"        var y = [",
				"            [data['phase_1'][n_intervals]],",
				"            [data['phase_2'][n_intervals]],",
				"            [data['phase_3'][n_intervals]],",
				"        ];",
				"        var data = {x: x, y: y};",
				"        var indices = [0, 1, 2];",
				"        var MAX_POINTS = 200;",
				"        return [data, indices, MAX_POINTS]",
				"    }",
				"    ''',",
				"    Output('clientside-graph', 'extendData'),",
				"    [Input('interval', 'n_intervals'), State('sin_wave', 'data')],",
				")",
				"",
				"if __name__ == '__main__':",
				"    app.run(debug=True)"
		],
		"description":"클라이언트 사이드 콜백을 활용한 extendData 애니메이션입니다."
	},
	"dash_5_extendData_user_code_snippet":{
		"prefix":"dash_5_extendData_user_code_snippet",
		"body":[
				"# 클라이언트 사이드 콜백을 활용한 extendData 애니메이션입니다.",
				"from dash import Dash, dcc, html, Input, Output",
				"import numpy as np",
				"",
				"MAX_DISPLAYED_POINTS = 100",
				"",
				"figure = dict(  # 이게 선언이 안 되면 extendData 작동 안 함.",
				"    data=[{'x': [], 'y': []}, {'x': [], 'y': []}],",
				")",
				"",
				"app = Dash(__name__)",
				"app.layout = html.Div(",
				"    [dcc.Graph(id='graph', figure=figure), dcc.Interval(id='interval', interval=50)]",
				")",
				"@app.callback(",
				"    Output('graph', 'extendData'),",
				"    Input('interval', 'n_intervals'),",
				")",
				"def update_data(n):",
				"    # The things below should be considerd",
				"    # 1. Shape of x and y must be same. For example) assert np.array(x).shape == np.array(y).shape.",
				"    if n is None:",
				"        n = 0",
				"    x = [",
				"        [n, n + 1],",
				"        [n, n + 1],",
				"    ]",
				"    y = [",
				"        [np.sin(n * 0.1), np.sin((n + 1) * 0.1)],",
				"        [np.cos(n * 0.1), np.cos((n + 1) * 0.1)],",
				"    ]",
				"    assert (",
				"        np.array(x).shape == np.array(y).shape",
				"    ), 'Shape of x and y must be same. If not extendData will not work.'",
				"    data = {'x': x, 'y': y}",
				"    update_trace_indexes = [i for i in range(len(x))]  # [0, 1]",
				"",
				"    return (",
				"        data,",
				"        update_trace_indexes,",
				"        MAX_DISPLAYED_POINTS,",
				"    )",
				"",
				"",
				"if __name__ == '__main__':",
				"    app.run_server()"
		],
		"description":"dash extendData 애니메이션입니다."
	},
	"dash_4_animation_subplots_user_code_snippet":{
		"prefix":"dash_4_animation_subplots_user_code_snippet",
		"body":[
				"# https://plotly.com/javascript/subplots/",
				"from dash import Dash, dcc, html, Input, Output, clientside_callback, State",
				"import pandas as pd",
				"import numpy as np",
				"",
				"df = pd.DataFrame(",
				"    {",
				"        'x': [i for i in range(10000)],",
				"        'phase_1': [np.sin(4 * np.pi * i * 0.01) for i in range(10000)],",
				"        'phase_2': [",
				"            np.sin(4 * np.pi * i * 0.01 - 2 * (np.pi) / 3) for i in range(10000)",
				"        ],",
				"        'phase_3': [np.sin(4 * np.pi * i * 0.01 - (np.pi) / 3) for i in range(10000)],",
				"    }",
				")",
				"",
				"app = Dash(__name__)",
				"app.layout = html.Div(",
				"    [",
				"        dcc.Graph(id='clientside-graph'),",
				"        dcc.Interval(id='interval', interval=1000 / 24),",
				"        dcc.Store(id='sin_wave', data=df.to_dict('list')),",
				"    ]",
				")",
				"",
				"",
				"clientside_callback(",
				"    '''",
				"    function(n_intervals, data) {",
				"        ",
				"        var phase_1_voltage = {",
				"                        'x':data['x'].slice(0,n_intervals),",
				"                        'y':data['phase_1'].slice(0,n_intervals)",
				"                    };",
				"        var phase_2_voltage = {",
				"                        'x':data['x'].slice(0,n_intervals),",
				"                        'y':data['phase_2'].slice(0,n_intervals),",
				"                        xaxis: 'x2',",
				"                        yaxis: 'y2',",
				"                    };",
				"        var phase_3_voltage = {",
				"                        'x':data['x'].slice(0,n_intervals),",
				"                        'y':data['phase_3'].slice(0,n_intervals),",
				"                        xaxis: 'x3',",
				"                        yaxis: 'y3',",
				"                    };",
				"        var phase_total_1_voltage = {",
				"                        'x':data['x'].slice(0,n_intervals),",
				"                        'y':data['phase_1'].slice(0,n_intervals),",
				"                        xaxis: 'x4',",
				"                        yaxis: 'y4',",
				"                    };",
				"        var phase_total_2_voltage = {",
				"                        'x':data['x'].slice(0,n_intervals),",
				"                        'y':data['phase_2'].slice(0,n_intervals),",
				"                        xaxis: 'x4',",
				"                        yaxis: 'y4',",
				"                    };",
				"        var phase_total_3_voltage = {",
				"                        'x':data['x'].slice(0,n_intervals),",
				"                        'y':data['phase_3'].slice(0,n_intervals),",
				"                        xaxis: 'x4',",
				"                        yaxis: 'y4',",
				"                    };",
				"        ",
				"        var data = [phase_1_voltage, phase_2_voltage, phase_3_voltage, phase_total_1_voltage, phase_total_2_voltage, phase_total_3_voltage];",
				"                ",
				"        var layout = {grid: {rows: 2, columns: 2, pattern: 'independent'}}",
				"        return {'data':data, 'layout':layout};",
				"    }",
				"    ''',",
				"    Output('clientside-graph', 'figure'),",
				"    [Input('interval', 'n_intervals')],",
				"    [State('sin_wave', 'data')],",
				")",
				"",
				"if __name__ == '__main__':",
				"    app.run(debug=True)"
		],
		"description":"dash subplots 애니메이션입니다."
	},
	"pil_1_gif_user_code_snippet":{
		"prefix":"pil_1_gif_user_code_snippet",
		"body":[
				"# %%",
				"# 개별 이미지를 gif로 합칩니다.",
				"",
				"from randimage import get_random_image  # pip install randimage",
				"import matplotlib",
				"from PIL import Image",
				"",
				"from pathlib import Path",
				"import sys",
				"",
				"image_folder = Path(sys.path[0]) / Path('image_folder')",
				"image_folder.mkdir(parents=True, exist_ok=True)",
				"",
				"gif_file = sys.path[0] + '/result_gif.gif'",
				"",
				"",
				"# 이미지 생성",
				"def random_image(path, size=(32, 32)):",
				"    matplotlib.image.imsave(path, get_random_image(size))",
				"",
				"",
				"for i in range(50):",
				"    random_image(image_folder / Path(f'{i}.png'))",
				"",
				"",
				"def convert_to_animated_gif(image_files, gif_file, fps=12):",
				"    try:",
				"        frames = [Image.open(file) for file in image_files]",
				"",
				"        image = Image.open(image_files[0])",
				"        image.save(",
				"            gif_file,",
				"            format='GIF',",
				"            append_images=frames[1:],",
				"            save_all=True,",
				"            duration=int(1000 / fps),",
				"            loop=0,",
				"        )",
				"",
				"        print(f'Converted image files to {gif_file}')",
				"    except Exception as e:",
				"        print(f'Error converting image files to GIF: {str(e)}')",
				"",
				"",
				"convert_to_animated_gif(list(image_folder.glob('*.*')), gif_file)",
				"",
				"# %%",
				"# gif 애니메이션 파일을 개별 이미지로 분할합니다.",
				"",
				"from PIL import Image",
				"import sys",
				"from pathlib import Path",
				"",
				"image_folder = Path(sys.path[0]) / Path('image_folder')",
				"image_folder.mkdir(parents=True, exist_ok=True)",
				"gif_file = sys.path[0] + '/result_gif.gif'",
				"dir = Path(f'{sys.path[0]}/gif_extract')",
				"",
				"dir.mkdir(exist_ok=True, parents=True)",
				"gif_image = Image.open(gif_file)",
				"for frame_num in range(gif_image.n_frames):",
				"    gif_image.seek(frame_num)",
				"    gif_image.save(f'{dir.as_posix()}/gif_{frame_num:03d}.gif')"
		],
		"description":"애니메이션 &lt;-&gt; 개별 이미지 상호 변환 코드입니다."
	},
	"pytorch_4_simple_model_user_code_snippet":{
		"prefix":"pytorch_4_simple_model_user_code_snippet",
		"body":[
				"# %%",
				"# pytorch 회귀 모델입니다.",
				"",
				"###########################################################################################",
				"###########################################################################################",
				"# 이 아래는 공통 활용 코드로 수정 불필요",
				"",
				"import torch",
				"import torch.nn as nn",
				"from torch.utils.data import Dataset, DataLoader",
				"from sklearn.metrics import r2_score, accuracy_score",
				"",
				"",
				"class MyDataset(Dataset):",
				"    def __init__(self, X, y):",
				"        self.X = X",
				"        self.y = y",
				"",
				"    def __len__(self):",
				"        return len(self.X)",
				"",
				"    def __getitem__(self, idx):",
				"        return self.X[idx], self.y[idx]",
				"",
				"",
				"def train(model, X, y, loss_function, batch_size=32, epochs=1000):",
				"    train_loader = DataLoader(dataset=MyDataset(X, y), batch_size=batch_size)",
				"    optimizer = torch.optim.Adam(model.parameters())",
				"    for epoch in range(epochs):",
				"        for X, y in train_loader:",
				"            optimizer.zero_grad()",
				"            loss = loss_function(model(X), y)",
				"            loss.backward()",
				"            optimizer.step()",
				"",
				"        # Print loss",
				"        if epoch % 100 == 0:",
				"            print(f'Epoch {epoch}, Loss: {loss.data}')",
				"    return model",
				"",
				"",
				"def calculate_score(model, X, y, loss_function):",
				"    model.eval()",
				"    with torch.no_grad():",
				"        y_pred = model(X)",
				"        if isinstance(loss_function, nn.MSELoss):",
				"            score = r2_score(y, y_pred)",
				"        elif isinstance(loss_function, nn.BCEWithLogitsLoss) or isinstance(",
				"            loss_function, nn.CrossEntropyLoss",
				"        ):",
				"            y_pred = torch.argmax(y_pred, dim=1)",
				"            score = accuracy_score(y, y_pred)",
				"        else:",
				"            raise ValueError('Unsupported loss function')",
				"",
				"    return score",
				"",
				"",
				"# 이 위까지는 공통 활용 코드로 수정 불필요",
				"###########################################################################################",
				"###########################################################################################",
				"",
				"# %%",
				"# 회귀 모델입니다.",
				"",
				"from sklearn.datasets import make_regression",
				"import random",
				"from sklearn.model_selection import train_test_split",
				"",
				"X, y = make_regression(n_samples=1000)",
				"y = y.reshape(-1, 1)",
				"X_train, X_test, y_train, y_test = train_test_split(X, y)",
				"BATCH_SIZE = 32",
				"EPOCHS = 1000",
				"# hidden_size : hidden unit 사이즈 : 아무 size나 해도 된다는 걸 표현하기 위해 random 사용",
				"input_size, hidden_size, output_size = X_train.shape[1], random.randint(30, 60), 1",
				"model = nn.Sequential(",
				"    nn.Linear(input_size, hidden_size), nn.ReLU(), nn.Linear(hidden_size, output_size)",
				")",
				"model = train(",
				"    model,",
				"    X_train,",
				"    y_train,",
				"    loss_function := nn.MSELoss(),",
				"    epochs=EPOCHS,",
				"    batch_size=BATCH_SIZE,",
				")",
				"score = calculate_score(model, X_test, y_test, loss_function)",
				"print(f'R2 Score: {score}')",
				"# %%",
				"# 분류 모델입니다.",
				"",
				"from sklearn.datasets import make_classification",
				"",
				"X, y = make_classification(n_samples=1000)",
				"X, y = torch.FloatTensor(X), torch.LongTensor(y)",
				"X_train, X_test, y_train, y_test = train_test_split(X, y)",
				"BATCH_SIZE = 32",
				"EPOCHS = 1000",
				"# hidden_size : hidden unit 사이즈 : 아무 size나 해도 된다는 걸 표현하기 위해 random 사용",
				"# output_size가 회귀 모델과 다름",
				"input_size, hidden_size, output_size = X_train.shape[1], random.randint(30, 60), 2",
				"# 회귀 모델과 동일한 형태의 모델",
				"model = nn.Sequential(",
				"    nn.Linear(input_size, hidden_size), nn.ReLU(), nn.Linear(hidden_size, output_size)",
				")",
				"model = train(",
				"    model,",
				"    X_train,",
				"    y_train,",
				"    loss_function := nn.CrossEntropyLoss(),",
				"    epochs=EPOCHS,",
				"    batch_size=BATCH_SIZE,",
				")",
				"score = calculate_score(model, X_test, y_test, loss_function)",
				"print(f'Accuracy Score: {score}')"
		],
		"description":"간소화환 회귀 및 분류 모델입니다."
	},
	"dash_3_gallery_user_code_snippet":{
		"prefix":"dash_3_gallery_user_code_snippet",
		"body":[
			"# %%",
			"# 갤러리 기능입니다. carousel이 비슷한 기능을 지원하지만, dcc.Graph() 객체를 표시하기 위해선 아래 방식을 사용해야 합니다.",
			"# 패키지 불러오기",
			"import dash",
			"import dash_bootstrap_components as dbc",
			"from dash import Input, Output, html, State, dcc",
			"from randimage import get_random_image  # pip install randimage",
			"import matplotlib",
			"",
			"import sys",
			"from pathlib import Path",
			"",
			"# 반드시 assets라는 이름이어야 함. 다른 건 dash가 로컬에서 읽지 못함.",
			"path = Path(sys.path[0]) / Path('assets')",
			"path.mkdir(parents=True, exist_ok=True)",
			"",
			"",
			"def random_image(index, size=(128, 128)):",
			"    matplotlib.image.imsave(path / Path(f'{index}.png'), get_random_image(size))",
			"",
			"",
			"# %%",
			"# 레이아웃 구성",
			"top_card = dbc.Card(",
			"    children=[",
			"        dbc.CardImg(src='assets/0.png', top=True, id='top'),",
			"        dbc.CardBody(",
			"            html.P(",
			"                'This card has an image at the top',",
			"                className='card-text',",
			"                id='top_text',",
			"            )",
			"        ),",
			"        dbc.Button('Previous', color='primary', id='previous'),",
			"    ],",
			"    style={'width': '18rem'},",
			")",
			"",
			"bottom_card = dbc.Card(",
			"    children=[",
			"        dbc.CardBody(",
			"            html.P(",
			"                'This has a bottom image',",
			"                className='card-text',",
			"                id='bottom_text',",
			"            )",
			"        ),",
			"        dbc.CardImg(src='assets/0.png', bottom=True, id='bottom'),",
			"        dbc.Button('Next', color='primary', id='next'),",
			"    ],",
			"    style={'width': '18rem'},",
			")",
			"",
			"cards = dbc.Row(",
			"    [",
			"        dbc.Col(top_card, width='auto'),",
			"        dbc.Col(bottom_card, width='auto'),",
			"    ]",
			")",
			"",
			"app = dash.Dash(external_stylesheets=[dbc.themes.DARKLY])",
			"app.layout = html.Div([cards, dcc.Store(id='image_index')])",
			"",
			"",
			"@app.callback(",
			"    [",
			"        Output('top', 'src'),",
			"        Output('bottom', 'src'),",
			"        Output('top_text', 'children'),",
			"        Output('bottom_text', 'children'),",
			"        Output('image_index', 'data'),",
			"    ],",
			"    [Input('previous', 'n_clicks'), Input('next', 'n_clicks')],",
			"    State('image_index', 'data'),",
			")",
			"def previous_callback(previous, next, image_index):",
			"    if previous is None:",
			"        previous = 0",
			"    if next is None:",
			"        next = 0",
			"    image_index = next - previous",
			"    if not (path / Path(f'{image_index}.png')).exists():",
			"        random_image(image_index)",
			"    if not (path / Path(f'{image_index+1}.png')).exists():",
			"        random_image(image_index + 1)",
			"",
			"    return [",
			"        f'assets/{image_index}.png',",
			"        f'assets/{image_index+1}.png',",
			"        f'assets/{image_index}.png',",
			"        f'assets/{image_index+1}.png',",
			"        image_index,",
			"    ]",
			"",
			"",
			"if __name__ == '__main__':",
			"    app.run_server(debug=True)"
		],
		"description":"dash 갤러리 기능입니다."
	}
}